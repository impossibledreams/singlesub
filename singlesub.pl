#!/usr/bin/perl
#
#   SingleSub v0.1.1
#   Written by Yakov Shafranovich
#
#   A Project of SolidMatrix Research
#   Website: http://singlesub.sourceforge.net
#   Email:  research@solidmatrix.com
#   
#   ---------------------------------------------------
#   Copyright (C) 2005 SolidMatrix Technologies, Inc.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#   ---------------------------------------------------
#   o The cgi_buffer module v0.3 is (c) 2000 Copyright Mark Nottingham <mnot@pobox.com>
#   o IO::String module v1.06 is copyright 1998-2004 Gisle Aas.
#	o Nested list collapsing script written by Mark Wilton-Jones - 21/11/2003 - v2.2.0.
#   o The output generated by the 'quicksub' type is licensed under the GPL and is
#   based on quickSub 0.3.5. Copyright Jason Brome 2003-2005. All rights reserved.
#
#   All modules are being distributed under license, for more information see the
#   module files directly.
#   ---------------------------------------------------
#

use CGI;
use CGI::Carp qw(fatalsToBrowser);
use Crypt::SSLeay;
use LWP::UserAgent;
use URI::Escape;
use XML::LibXML;
use XML::LibXSLT;

require 5.004;
use cgi_buffer;
$cgi_buffer::generate_etag = 0;

#--- User Configuration Information ---
# no configuration at this time

#--- NO CONFIGURATION BELOW THIS --
#--- Variables --
my $version = 'singlesub/0.1.1 (http://singlesub.sf.net)';
my $content_type = '';
my $output_xsl = '';
my $feed_url = '';
my $opml_url = '';

#--- Check parameters --
if ($ENV{'REQUEST_METHOD'} eq "GET")
   { $in = $ENV{'QUERY_STRING'}; }
else
   { $in = <STDIN>; }
$q=new CGI($in);

if($q->param('type') eq '')
{  print "Content-Type: text/plain\n\n";
   print "500 ERROR: Missing parameter 'type'.\n";
   exit;
}

#--- Parse 'type' and 'feed' parameters ---
if($q->param('type') eq 'quicksub') {
   $output_xsl = 'templates/quicksub.xsl';
   $content_type = 'text/javascript';
} elsif($q->param('type') eq 'chicklet') {
   if($q->param('feed') eq '')
   {  print "Content-Type: text/plain\n\n";
      print "500 ERROR: Missing parameter 'feed' which is required for this type.\n";
      exit;
   }
   $output_xsl = 'templates/chicklet.xsl';
   $feed_url = $q->param('feed');
   $content_type = 'text/javascript';
} elsif($q->param('type') eq 'opml') {
   $output_xsl = 'templates/opml.xsl';
   $content_type = 'text/x-opml';
} elsif($q->param('type') eq 'rss2') {
   $output_xsl = 'templates/rss2.xsl';
   $content_type = 'text/xml';
} elsif($q->param('type') eq 'rdf') {
   $output_xsl = 'templates/rdf.xsl';
   $content_type = 'application/rdf+xml';
} elsif($q->param('type') eq 'html') {
   if($q->param('feed') eq '')
   {  print "Content-Type: text/plain\n\n";
      print "500 ERROR: Missing parameter 'feed' which is required for this type.\n";
      exit;
   }
   $output_xsl = 'templates/html.xsl';
   $content_type = 'text/html';
   $feed_url = $q->param('feed');
} else {
   print "Content-Type: text/plain\n\n";
   print "500 ERROR: This type is not supported.\n";
   exit;
}
 
#--- Create input request ---
my $parser = XML::LibXML->new();
my $xslt = XML::LibXSLT->new();
my $source;

#--- Parse input OPML file ---
if($q->param('opml_url') eq '') {
	$source = $parser->parse_file('singlesub_opml.xml');
} else {
	my $req;
	$ua = LWP::UserAgent->new;
	$ua->agent($version);
	$ua->from('comments@shaftek.org');
	$req = HTTP::Request->new(GET => $q->param('opml_url'));

	my $res = $ua->request($req);
	if ($res->is_error) {
    	print "Content-Type: text/plain\n\n";
	    print "500 OPML Request Failed: ", $res->status_line, "\n";
	    exit;	
	}
	$source = $parser->parse_string($res->content);
}

#--- Process request ---
my $style_doc = $parser->parse_file($output_xsl);
my $stylesheet = $xslt->parse_stylesheet($style_doc);
my $results = $stylesheet->transform($source,
	XML::LibXSLT::xpath_to_string(version => $version),
	XML::LibXSLT::xpath_to_string(feed_url => $feed_url),
	XML::LibXSLT::xpath_to_string(feed_url_escaped => uri_escape($feed_url))
	);

print "Content-Type: $content_type\n\n";
print $stylesheet->output_string($results);
exit;